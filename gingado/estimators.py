# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_estimators.ipynb.

# %% ../00_estimators.ipynb 2
#| include: false
#| echo: false
from __future__ import annotations # allows multiple typing of arguments in Python versions prior to 3.10

# %% auto 0
__all__ = ['FindCluster', 'MachineControl']

# %% ../00_estimators.ipynb 9
#| include: false
import numpy as np
from sklearn.base import BaseEstimator, ClusterMixin
from sklearn.cluster import AffinityPropagation
from sklearn.utils.metaestimators import available_if

# %% ../00_estimators.ipynb 10
#| include: false
class FindCluster(BaseEstimator):
    "Retain only the columns of `X` that are in the same cluster as `y`."

    def __init__(
        self,
        cluster_alg:[BaseEstimator,ClusterMixin]=AffinityPropagation(), # An instance of the clustering algorithm to use
        random_state:int|None=None, # The random seed to be used by the algorithm, if relevant
    ):
        self.cluster_alg = cluster_alg
        self.random_state = random_state
        if hasattr(self.cluster_alg, "random_state"):
            self.cluster_alg.set_params(random_state=self.random_state)


    def fit(
        self,
        X, # The population of entities, organised in columns
        y # The entity of interest
    ):
        "Fit `FindCluster`"
        temp_y_colname = "gingado_ycol"

        X[temp_y_colname] = y

        entities = X.columns
        y_mask = entities == temp_y_colname

        self.cluster_alg.fit(X.T)

        cluster = entities[self.cluster_alg.labels_ == self.cluster_alg.labels_[y_mask]]
        self.same_cluster_ = [e for e in cluster if e != temp_y_colname]
        return self

    def transform(
        self,
        X # The population of entities, organised in columns
    )->np.array: # Columns of `X` that are in the same cluster as `y`
        "Keep only the entities in `X` that belong to the same cluster as `y`"
        return X[self.same_cluster_]

    def fit_transform(
        self,
        X, # The population of entities, organised in columns
        y # The entity of interest
    )->np.array: # Columns of `X` that are in the same cluster as `y`
        "Fit a `FindCluster` object and keep only the entities in `X` that belong to the same cluster as `y`"
        self.fit(X, y)
        return self.transform(X)

# %% ../00_estimators.ipynb 33
#| include: false
import pandas as pd

from .benchmark import RegressionBenchmark
from .model_documentation import ggdModelDocumentation, ModelCard
from sklearn.base import check_is_fitted
from sklearn.pipeline import Pipeline
from sklearn.manifold import TSNE


# %% ../00_estimators.ipynb 34
#| include: false
class MachineControl(BaseEstimator):
    "Estimate synthetic controls with machine learning methods"

    def __init__(
        self,
        # An instance of the clustering algorithm to use, or None to retain all entities
        cluster_alg:[BaseEstimator,ClusterMixin]|None=AffinityPropagation(),
        # Method to weight the control entities
        estimator:BaseEstimator=RegressionBenchmark(), 
        # Algorithm for manifold learning
        manifold:BaseEstimator=TSNE(),
        # Include placebo estimations during prediction?
        with_placebo:bool=True,
        # The random seed to be used by the algorithm, if relevant
        random_state:int|None=None,
        # gingado Documenter template to facilitate model documentation
        auto_document:ggdModelDocumentation=ModelCard
    ):
        self.cluster_alg = cluster_alg,
        self.estimator = estimator
        self.manifold = manifold
        self.with_placebo = with_placebo
        self.random_state = random_state
        self.auto_document = auto_document

        if hasattr(self.cluster_alg, "random_state"):
            self.cluster_alg.set_params(random_state=self.random_state)
        if hasattr(self.estimator, "random_state"):
            self.estimator.set_params(random_state=self.random_state)
        if hasattr(self.manifold, "random_state"):
            self.manifold.set_params(random_state=self.random_state)    

        self.pipeline = Pipeline([
            ('donor_pool', self.cluster_alg),
            ('estimator', self.estimator)
        ])

    def _placebo(self):
        pass

    def _compare_controls(
        self,
        X:np.ndarray, # Array-like pre-intervention data of shape (n_samples, n_control_entites)
        y:np.ndarray # Array-like pre-intervention data of shape (n_samples,)
    )->[np.ndarray, np.ndarray]: # 2-d representation of the treated entity, controls, and the synthetic control
        "Calculates the 2-d manifold learning distribution"
        df_manifold_learning = pd.concat([X, y, self.machine_controls])
        self.manifold_repr = self.manifold.fit_transform(X=df_manifold_learning.T)

    def fit(
        self,
        X:np.ndarray, # Array-like pre-intervention data of shape (n_samples, n_control_entites)
        y:np.ndarray # Array-like pre-intervention data of shape (n_samples,)
    ):
        self.estimator.fit(X=X, y=y)
        self.machine_controls = self.estimator.predict(X=X)

        self._compare_controls()

        if self.with_placebo:
            self._placebo()

        return self

    def predict(
        self,
        X:np.ndarray, # Array-like data of shape (n_samples, n_control_entites)
    ):
        check_is_fitted(self.estimator)
        pred = self.estimator.predict(X=X)

        if self.with_placebo:
            self._placebo()

        return pred

