# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_estimators.ipynb.

# %% ../00_estimators.ipynb 2
#| include: false
#| echo: false
from __future__ import annotations # allows multiple typing of arguments in Python versions prior to 3.10

# %% auto 0
__all__ = ['FindCluster', 'MachineControl']

# %% ../00_estimators.ipynb 9
#| include: false
import numpy as np
from sklearn.base import BaseEstimator, ClusterMixin
from sklearn.cluster import AffinityPropagation
from sklearn.utils.metaestimators import available_if

# %% ../00_estimators.ipynb 10
#| include: false
class FindCluster(BaseEstimator):
    "Retain only the columns of `X` that are in the same cluster as `y`."

    def __init__(
        self,
        cluster_alg:[BaseEstimator,ClusterMixin]=AffinityPropagation(), # An instance of the clustering algorithm to use
        random_state:int|None=None, # The random seed to be used by the algorithm, if relevant
    ):
        self.cluster_alg = cluster_alg
        self.random_state = random_state
        if hasattr(self.cluster_alg, "random_state"):
            self.cluster_alg.set_params(random_state=self.random_state)


    def fit(
        self,
        X, # The population of entities, organised in columns
        y # The entity of interest
    ):
        "Fit `FindCluster`"
        temp_y_colname = "gingado_ycol"

        X[temp_y_colname] = y

        entities = X.columns
        y_mask = entities == temp_y_colname

        self.cluster_alg.fit(X.T)

        cluster = entities[self.cluster_alg.labels_ == self.cluster_alg.labels_[y_mask]]
        self.same_cluster_ = [e for e in cluster if e != temp_y_colname]
        return self

    def transform(
        self,
        X # The population of entities, organised in columns
    )->np.array: # Columns of `X` that are in the same cluster as `y`
        "Keep only the entities in `X` that belong to the same cluster as `y`"
        return X[self.same_cluster_]

    def fit_transform(
        self,
        X, # The population of entities, organised in columns
        y # The entity of interest
    )->np.array: # Columns of `X` that are in the same cluster as `y`
        "Fit a `FindCluster` object and keep only the entities in `X` that belong to the same cluster as `y`"
        self.fit(X, y)
        return self.transform(X)

# %% ../00_estimators.ipynb 33
#| include: false
import pandas as pd

from .benchmark import ggdBenchmark, RegressionBenchmark
from .model_documentation import ggdModelDocumentation, ModelCard
from sklearn.base import check_is_fitted
from sklearn.pipeline import Pipeline
from sklearn.manifold import TSNE
from scipy.spatial.distance import pdist, squareform

# %% ../00_estimators.ipynb 34
#| include: false
class MachineControl(BaseEstimator):
    "Estimate synthetic controls with machine learning methods"

    def __init__(
        self,
        # An instance of the clustering algorithm to use, or None to retain all entities
        cluster_alg:[BaseEstimator,ClusterMixin]|None=AffinityPropagation(),
        # Method to weight the control entities
        estimator:BaseEstimator=RegressionBenchmark(), 
        # Algorithm for manifold learning
        manifold:BaseEstimator=TSNE(),
        # Include placebo estimations during prediction?
        with_placebo:bool=True,
        # The random seed to be used by the algorithm, if relevant
        random_state:int|None=None,
        # gingado Documenter template to facilitate model documentation
        auto_document:ggdModelDocumentation=ModelCard
    ):
        self.cluster_alg = cluster_alg
        self.estimator = estimator
        self.manifold = manifold
        self.with_placebo = with_placebo
        self.random_state = random_state
        self.auto_document = auto_document

        if hasattr(self.cluster_alg, "random_state"):
            self.cluster_alg.set_params(random_state=self.random_state)
        if hasattr(self.estimator, "random_state"):
            self.estimator.set_params(random_state=self.random_state)
        if hasattr(self.manifold, "random_state"):
            self.manifold.set_params(random_state=self.random_state)    

        self.pipeline = Pipeline([
            ('donor_pool', self.cluster_alg),
            ('estimator', self.estimator)
        ])

    def _placebo(self):
        pass

    def _select_controls(
        self,
        X:pd.DataFrame, # A pandas DataFrame with pre-intervention data of shape (n_samples, n_control_entites)
        y:pd.DataFrame|pd.Series # A pandas DataFrame or Series with pre-intervention data of shape (n_samples,)
    ): # 
        "Identifies which columns of `X` should be used as controls"
        if self.cluster_alg is None:
            self.donor_pool_ = X.columns
        else:
            Xy = pd.concat([X, y], axis=1)
            self.cluster_alg.fit(Xy.T)
            idx_y = Xy.columns == y.name
            self.donor_pool_ = [
                c for c in Xy.columns[self.cluster_alg.labels_ == self.cluster_alg.labels_[idx_y]]
                if c != y.name
            ]

    def get_controls(self):
        "Get the list of control entities"
        if hasattr(self, "donor_pool_"):
            return self.donor_pool_
        else:
            "Controls not selected yet"

    def _compare_controls(
        self,
        X:np.ndarray, # Array-like pre-intervention data of shape (n_samples, n_control_entites)
        y:np.ndarray # Array-like pre-intervention data of shape (n_samples,)
    )->[np.ndarray, np.ndarray]: # 2-d representation of the treated entity, controls, and the synthetic control
        "Calculates the 2-d manifold learning distribution and locates the distance between target and control in this distribution"
        df_manifold_learning = pd.concat([
            pd.DataFrame(X), 
            pd.DataFrame(self.machine_controls_),
            pd.DataFrame(y) # if actual data is last, it is easier to do the distance learning
        ], axis=1)
        self.manifold_embed_ = self.manifold.fit_transform(X=df_manifold_learning.T)
        self.distances_ = squareform(pdist(self.manifold_embed_))[-1,:-1] # last position in the resulting array is the dist between actual and synth control
        self.control_quality_test_ = np.percentile(self.distances_, self.distances_[-1])

    def fit(
        self,
        X:pd.DataFrame, # A pandas DataFrame with pre-intervention data of shape (n_samples, n_control_entites)
        y:pd.DataFrame|pd.Series # A pandas DataFrame or Series with pre-intervention data of shape (n_samples,)
    ):
        "Fit the `MachineControl` model"
        
        self._select_controls(X=X, y=y)
        
        X_donor, y = self._validate_data(X[self.donor_pool_], y)
        
        self.estimator.fit(X=X_donor, y=y)
        
        self.machine_controls_ = self.estimator.predict(X=X_donor)

        # for the comparison part, note we use everyone, not just the selected control entities
        # this allows us to use a more robust test of whether there are many out-of-cluster entity
        # that would by itself be closer to the target entity.
        self._compare_controls(X=X.values, y=y)

        if self.with_placebo:
            self._placebo()

        return self

    def predict(
        self,
        X:pd.DataFrame # A pandas DataFrame with complete time series (pre- and post-intervention) of shape (n_samples, n_control_entites)
    ):
        "Calculate the model predictions before and after the intervention"
        check_is_fitted(self.estimator)
        pred = self.estimator.predict(X=X)

        if self.with_placebo:
            self._placebo()

        return pred

