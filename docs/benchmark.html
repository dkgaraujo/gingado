---

title: Automatic benchmark model


keywords: fastai
sidebar: home_sidebar

summary: "Functions to create a relevant, fast and reasonably well-performing benchmark"
description: "Functions to create a relevant, fast and reasonably well-performing benchmark"
nb_path: "00_benchmark.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_benchmark.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A <code>Benchmark</code> object has a similar API to a <code>sciki-learn</code> estimator: you build an instance with the desired arguments, and fit it to the data at a later moment.</p>
<p><code>Benchmark</code> is a convenience wrapper for reading the training data, passing it through a simplified pipeline consisting of data imputation and a standard scalar, and then the benchmark function calibrated with a grid search.</p>
<p>A <code>Benchmark</code> comprises the following steps, all glued together:</p>
<ul>
<li>split the dataset into a training and a test datasets</li>
<li>a <code>Pipeline</code> that consisting of a data imputation, a standard scaler, and a random forest estimator</li>
<li>a grid search object</li>
</ul>
<p>The user may include her own data split and/or pipeline in the benchmark object. If none is present, the benchmark object will create one. The user may also include her own grid search parameter preferences, but that is also not required for the <code>Benchmark</code> to be instanciated appropriately.</p>
<p>In addition to the estimator methods <code>Benchmark</code> has by virtue of itself being an estimator, these objects also have a <code>compare</code> method, which takes as argument another fitted estimator (which could be itself a solo estimator or a whole pipeline) or a list of estimators.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ggdBenchmark" class="doc_header"><code>class</code> <code>ggdBenchmark</code><a href="https://github.com/dkgaraujo/gingado/tree/main/gingado/benchmark.py#L8" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ggdBenchmark</code>() :: <code>BaseEstimator</code></p>
</blockquote>
<p>Base class for all estimators in scikit-learn.</p>
<h2 id="Notes">Notes<a class="anchor-link" href="#Notes"> </a></h2><p>All estimators should specify all the parameters that can be set
at the class level in their <code>__init__</code> as explicit keyword
arguments (no <code>*args</code> or <code>**kwargs</code>).</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

